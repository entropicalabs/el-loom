{
  "empty_circuit": {
    "program": [
      "# empty input"
    ],
    "program_catalyst": [
      "# empty input"
    ]
  },
  "simple_circuit": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'2f599a6f-219d-48f4-a706-183ab94aed6b': 1})",
      "",
      "# Start of circuit: simple_circuit",
      "qml.measure(0, reset=True)",
      "qml.PauliX([0])",
      "measurements[\"c0\"] = qml.measure(0)",
      "#  End of circuit: simple_circuit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'2f599a6f-219d-48f4-a706-183ab94aed6b': 1})",
      "",
      "# Start of circuit: simple_circuit",
      "catalyst_measure(0, reset=True)",
      "qml.PauliX([0])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "#  End of circuit: simple_circuit"
    ]
  },
  "bell_state_circuit": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'9454e826-acc3-4d0f-9ab5-2c347f4b3e88': 1, '30b0f827-edc8-42c3-a569-c728b6c822e4': 1})",
      "",
      "# Start of circuit: bell_state_circuit",
      "qml.Hadamard([0])",
      "qml.CNOT([0, 1])",
      "measurements[\"c0\"] = qml.measure(0)",
      "measurements[\"c1\"] = qml.measure(1)",
      "#  End of circuit: bell_state_circuit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'9454e826-acc3-4d0f-9ab5-2c347f4b3e88': 1, '30b0f827-edc8-42c3-a569-c728b6c822e4': 1})",
      "",
      "# Start of circuit: bell_state_circuit",
      "qml.Hadamard([0])",
      "qml.CNOT([0, 1])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "#  End of circuit: bell_state_circuit"
    ]
  },
  "circuit_with_nested_circuits": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'7ecdaac3-05cd-4c1f-9c2a-04955e2a2d4b': 1, 'b02c431c-bfbb-47a3-9e7c-a1e7aa9ebfed': 1, '67a849c6-a34a-41c0-bd95-31ed38f686f3': 1})",
      "",
      "# Start of circuit: nested_circuit",
      "qml.measure(0, reset=True)",
      "qml.Hadamard([1])",
      "qml.CNOT([0, 1])",
      "qml.Hadamard([0])",
      "qml.CNOT([1, 2])",
      "measurements[\"c0\"] = qml.measure(0)",
      "measurements[\"c1\"] = qml.measure(1)",
      "measurements[\"c2\"] = qml.measure(2)",
      "#  End of circuit: nested_circuit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'7ecdaac3-05cd-4c1f-9c2a-04955e2a2d4b': 1, 'b02c431c-bfbb-47a3-9e7c-a1e7aa9ebfed': 1, '67a849c6-a34a-41c0-bd95-31ed38f686f3': 1})",
      "",
      "# Start of circuit: nested_circuit",
      "catalyst_measure(0, reset=True)",
      "qml.Hadamard([1])",
      "qml.CNOT([0, 1])",
      "qml.Hadamard([0])",
      "qml.CNOT([1, 2])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "measurements[\"c2\"] = catalyst_measure(2)",
      "#  End of circuit: nested_circuit"
    ]
  },
  "circuit_with_multiple_nested_levels": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'76da8cc8-bac2-4a6d-ba30-09cf338f5d40': 1, '684ac5e6-42a1-40f3-9862-8cb387b0b0c6': 1, '7473fb65-c3b3-47cd-929c-a58afea9710c': 1, '84fcb417-fb97-4b76-a315-cb501ce889d2': 1})",
      "",
      "# Start of circuit: multi_nested_circuit",
      "qml.measure(0, reset=True)",
      "qml.Hadamard([1])",
      "qml.CNOT([0, 3])",
      "qml.CNOT([1, 2])",
      "qml.Hadamard([0])",
      "# Start of circuit: sub_nested",
      "qml.CNOT([2, 3])",
      "qml.measure(1, reset=True)",
      "#  End of circuit: sub_nested",
      "measurements[\"c0\"] = qml.measure(0)",
      "measurements[\"c1\"] = qml.measure(1)",
      "#  End of circuit: multi_nested_circuit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'d32a5ed7-f323-443e-9e04-5992240457cd': 1, '08b67b8e-aebd-4f7c-ab34-c3a1d1ba8cd1': 1, 'a6c59ca5-035c-46a0-917d-a278365ae55b': 1, 'c2aa45be-9fe3-434c-ae43-59b2308a1579': 1})",
      "",
      "# Start of circuit: multi_nested_circuit",
      "catalyst_measure(0, reset=True)",
      "qml.Hadamard([1])",
      "qml.CNOT([0, 3])",
      "qml.CNOT([1, 2])",
      "qml.Hadamard([0])",
      "# Start of circuit: sub_nested",
      "qml.CNOT([2, 3])",
      "catalyst_measure(1, reset=True)",
      "#  End of circuit: sub_nested",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "#  End of circuit: multi_nested_circuit"
    ]
  },
  "circuit_w_all_single_qubit_ops": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'f77e0e19-3f9d-4853-a0b1-e78c850acbfb': 1})",
      "",
      "# Start of circuit: circuit_w_all_single_qubit_ops",
      "qml.Identity([0])",
      "qml.PauliX([0])",
      "qml.PauliY([0])",
      "qml.PauliZ([0])",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "qml.adjoint(qml.S)([0])",
      "#  End of circuit: circuit_w_all_single_qubit_ops"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'c65cd18a-e7d2-4a49-8fcf-7d6d5c327ae6': 1})",
      "",
      "# Start of circuit: circuit_w_all_single_qubit_ops",
      "qml.Identity([0])",
      "qml.PauliX([0])",
      "qml.PauliY([0])",
      "qml.PauliZ([0])",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "qml.adjoint(qml.S)([0])",
      "#  End of circuit: circuit_w_all_single_qubit_ops"
    ]
  },
  "circuit_w_all_two_qubit_ops": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'66481364-db05-4bea-8dea-187cb9c23e8d': 1, '7f05f1a5-9541-4de0-8a22-ced28b8e7fd1': 1})",
      "",
      "# Start of circuit: circuit_w_all_two_qubit_ops",
      "qml.CNOT([0, 1])",
      "qml.CNOT([0, 1])",
      "qml.CY([0, 1])",
      "qml.CZ([0, 1])",
      "qml.SWAP([0, 1])",
      "#  End of circuit: circuit_w_all_two_qubit_ops"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'6b2583f0-8512-4e83-b511-793459c145c8': 1, '6c016f93-3eaa-48b1-bce8-d46729772f5d': 1})",
      "",
      "# Start of circuit: circuit_w_all_two_qubit_ops",
      "qml.CNOT([0, 1])",
      "qml.CNOT([0, 1])",
      "qml.CY([0, 1])",
      "qml.CZ([0, 1])",
      "qml.SWAP([0, 1])",
      "#  End of circuit: circuit_w_all_two_qubit_ops"
    ]
  },
  "circuit_w_all_reset_ops": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'2d8faae1-7f09-4495-a750-1a793b4f15b8': 1})",
      "",
      "# Start of circuit: circuit_w_all_reset_ops",
      "qml.measure(0, reset=True)",
      "qml.measure(0, reset=True)",
      "qml.measure(0, reset=True)",
      "qml.PauliX([0])",
      "qml.measure(0, reset=True)",
      "qml.Hadamard([0])",
      "qml.measure(0, reset=True)",
      "qml.PauliX([0])",
      "qml.Hadamard([0])",
      "qml.measure(0, reset=True)",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "qml.measure(0, reset=True)",
      "qml.PauliX([0])",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "#  End of circuit: circuit_w_all_reset_ops"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'5869686a-cae4-41f8-b9a3-a38f7d3d1ec3': 1})",
      "",
      "# Start of circuit: circuit_w_all_reset_ops",
      "catalyst_measure(0, reset=True)",
      "catalyst_measure(0, reset=True)",
      "catalyst_measure(0, reset=True)",
      "qml.PauliX([0])",
      "catalyst_measure(0, reset=True)",
      "qml.Hadamard([0])",
      "catalyst_measure(0, reset=True)",
      "qml.PauliX([0])",
      "qml.Hadamard([0])",
      "catalyst_measure(0, reset=True)",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "catalyst_measure(0, reset=True)",
      "qml.PauliX([0])",
      "qml.Hadamard([0])",
      "qml.S([0])",
      "#  End of circuit: circuit_w_all_reset_ops"
    ]
  },
  "circuit_w_all_measurement_ops": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'2e1232a3-af3f-449b-9c5b-3154b31e984d': 1})",
      "",
      "# Start of circuit: circuit_w_all_measurement_ops",
      "measurements[\"c0\"] = qml.measure(0)",
      "qml.measure(0, reset=True)",
      "measurements[\"c0\"] = qml.measure(0)",
      "qml.measure(0, reset=True)",
      "qml.Hadamard(0)",
      "measurements[\"c0\"] = qml.measure(0)",
      "qml.measure(0, reset=True)",
      "qml.adjoint(qml.S)(0)",
      "qml.Hadamard(0)",
      "measurements[\"c0\"] = qml.measure(0)",
      "#  End of circuit: circuit_w_all_measurement_ops"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'713813c3-695f-4633-af80-d405dc7b037f': 1})",
      "",
      "# Start of circuit: circuit_w_all_measurement_ops",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "catalyst_measure(0, reset=True)",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "catalyst_measure(0, reset=True)",
      "qml.Hadamard(0)",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "catalyst_measure(0, reset=True)",
      "qml.adjoint(qml.S)(0)",
      "qml.Hadamard(0)",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "#  End of circuit: circuit_w_all_measurement_ops"
    ]
  },
  "circuit_with_simple_if_else": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'1cfcf1a3-4b4c-4b2c-b8a2-2533dabe8fb0': 1, 'd4d2a252-8dc1-466c-b5c1-59187809f694': 1})",
      "",
      "# Start of circuit: circuit_with_if_else",
      "qml.Hadamard([0])",
      "measurements[\"c0\"] = qml.measure(0)",
      "def call_if_true():",
      "    qml.PauliX([1])",
      "def call_else():",
      "    qml.PauliZ([1])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "qml.cond(~(measurements[\"c0\"] == 1), call_else)()",
      "measurements[\"c1\"] = qml.measure(1)",
      "#  End of circuit: circuit_with_if_else"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'45727987-c099-4111-8256-4eeece6e3848': 1, '15cc2a58-3e65-4493-8366-c6bdea696a91': 1})",
      "",
      "# Start of circuit: circuit_with_if_else",
      "qml.Hadamard([0])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "def call_if_true():",
      "    qml.PauliX([1])",
      "def call_else():",
      "    qml.PauliZ([1])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "qml.cond(~(measurements[\"c0\"] == 1), call_else)()",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "#  End of circuit: circuit_with_if_else"
    ]
  },
  "circuit_if_with_empty_else": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'85b788af-abe1-4dde-81fb-9415271752d5': 1, '02cf0137-07e8-427e-99ce-feae6135fb99': 1})",
      "",
      "# Start of circuit: circuit_with_if_empty_else",
      "qml.Hadamard([0])",
      "measurements[\"c0\"] = qml.measure(0)",
      "def call_if_true():",
      "    qml.PauliX([1])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "measurements[\"c1\"] = qml.measure(1)",
      "#  End of circuit: circuit_with_if_empty_else"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'883483bc-6362-45b2-8b61-9f79bf5d558f': 1, 'dbe3b173-2cd6-44d3-aa5c-7a97f41f8228': 1})",
      "",
      "# Start of circuit: circuit_with_if_empty_else",
      "qml.Hadamard([0])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "def call_if_true():",
      "    qml.PauliX([1])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "#  End of circuit: circuit_with_if_empty_else"
    ]
  },
  "circuit_with_boolean_logic_condition": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'4c9ccfec-b8ad-4ad4-a52c-253ab6b3145d': 1, 'de530981-2fbc-4c99-9cd3-de20327af80a': 1, '85c90c46-51f0-4312-8dae-bf32f5dc2c10': 1})",
      "",
      "# Start of circuit: circuit_with_advanced_condition",
      "qml.Hadamard([0])",
      "qml.PauliX([1])",
      "measurements[\"c0\"] = qml.measure(0)",
      "measurements[\"c1\"] = qml.measure(1)",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)) , call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)) ), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1)), call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1))), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) ^ (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) ^ (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~(measurements[\"c0\"] == 1), call_if_true)()",
      "qml.cond(~(~(measurements[\"c0\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "qml.cond(~(measurements[\"c0\"] == 1), call_else)()",
      "measurements[\"c2\"] = qml.measure(2)",
      "#  End of circuit: circuit_with_advanced_condition"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'54fad8d2-c53f-4b97-87ad-f214cbb00b7c': 1, '5826d58e-3a46-437b-8f13-a55a84dbe220': 1, '29c05fe8-8959-43cf-8ec8-b9627c042ee4': 1})",
      "",
      "# Start of circuit: circuit_with_advanced_condition",
      "qml.Hadamard([0])",
      "qml.PauliX([1])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)) , call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1)) ), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1)), call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) | (measurements[\"c1\"] == 1))), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond((measurements[\"c0\"] == 1) ^ (measurements[\"c1\"] == 1), call_if_true)()",
      "qml.cond(~((measurements[\"c0\"] == 1) ^ (measurements[\"c1\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~(measurements[\"c0\"] == 1), call_if_true)()",
      "qml.cond(~(~(measurements[\"c0\"] == 1)), call_else)()",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "qml.cond(~(measurements[\"c0\"] == 1), call_else)()",
      "measurements[\"c2\"] = catalyst_measure(2)",
      "#  End of circuit: circuit_with_advanced_condition"
    ]
  },
  "circuit_w_nested_if_else": {
    "program": [],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'735af37f-5c2d-4736-a3a0-a205a94c7a5a': 1, '79c59a64-74da-4494-8f43-4ebcbc3685cf': 1})",
      "",
      "# Start of circuit: circuit_with_nested_if_else",
      "qml.Hadamard([0])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(1)",
      "def call_if_true():",
      "    def call_if_true():",
      "        qml.PauliX([1])",
      "    def call_else():",
      "        qml.PauliY([1])",
      "    qml.cond(measurements[\"c1\"] == 1, call_if_true)()",
      "    qml.cond(~(measurements[\"c1\"] == 1), call_else)()",
      "def call_else():",
      "    qml.PauliZ([1])",
      "qml.cond(measurements[\"c0\"] == 1, call_if_true)()",
      "qml.cond(~(measurements[\"c0\"] == 1), call_else)()",
      "measurements[\"c2\"] = catalyst_measure(1)",
      "#  End of circuit: circuit_with_nested_if_else"
    ]
  },
  "circuit_with_boolean_logic_condition_multibit": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'f93e02aa-b954-40db-b502-851484499e39': 1, 'd9e21acc-4d57-43fe-8e71-360270c47a15': 1, '5570aa5f-474b-47ee-a1c3-1869d2582168': 1})",
      "",
      "# Start of circuit: circuit_with_advanced_condition_multibit",
      "qml.Hadamard([0])",
      "qml.PauliX([1])",
      "measurements[\"c0\"] = qml.measure(0)",
      "measurements[\"c1\"] = qml.measure(0)",
      "measurements[\"c2\"] = qml.measure(0)",
      "measurements[\"c3\"] = qml.measure(0)",
      "measurements[\"c4\"] = qml.measure(0)",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1) & (measurements[\"c2\"] == 1) & (measurements[\"c3\"] == 1) & (measurements[\"c4\"] == 1)) , call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1) & (measurements[\"c2\"] == 1) & (measurements[\"c3\"] == 1) & (measurements[\"c4\"] == 1)) ), call_else)()",
      "measurements[\"c5\"] = qml.measure(2)",
      "#  End of circuit: circuit_with_advanced_condition_multibit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'0a3fd958-396c-4b6c-a2ae-5fbd7b51a756': 1, '1a3d3cde-0840-4b10-ad3e-29708b117c70': 1, 'fe97fef3-d73f-4969-b0fd-f7749004d132': 1})",
      "",
      "# Start of circuit: circuit_with_advanced_condition_multibit",
      "qml.Hadamard([0])",
      "qml.PauliX([1])",
      "measurements[\"c0\"] = catalyst_measure(0)",
      "measurements[\"c1\"] = catalyst_measure(0)",
      "measurements[\"c2\"] = catalyst_measure(0)",
      "measurements[\"c3\"] = catalyst_measure(0)",
      "measurements[\"c4\"] = catalyst_measure(0)",
      "def call_if_true():",
      "    qml.PauliX([2])",
      "def call_else():",
      "    qml.PauliZ([2])",
      "qml.cond(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1) & (measurements[\"c2\"] == 1) & (measurements[\"c3\"] == 1) & (measurements[\"c4\"] == 1)) , call_if_true)()",
      "qml.cond(~(~ ((measurements[\"c0\"] == 1) & (measurements[\"c1\"] == 1) & (measurements[\"c2\"] == 1) & (measurements[\"c3\"] == 1) & (measurements[\"c4\"] == 1)) ), call_else)()",
      "measurements[\"c5\"] = catalyst_measure(2)",
      "#  End of circuit: circuit_with_advanced_condition_multibit"
    ]
  },
  "circuit_surface_code_experiment": {
    "program": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'74f79bad-0a52-4c0c-9159-116d7c91a152': 1, '04f1e5c4-3de2-4286-9466-491b2d42381a': 1, 'a12069c6-4c19-4521-913c-ec65605423ce': 1, 'd0bb4e86-1c43-4f7b-9d54-a71528b863a6': 1, '6ef938d5-cc86-4174-a7f4-e167646f8d18': 1, 'b4fa406f-4e26-46dc-9ce9-57587ec8bb24': 1, 'd68cbad8-b7be-4949-895f-139e6b185d37': 1, '4bd8974a-45d6-4d20-a984-8fa26dd244e8': 1, '5b08c7c6-fd34-4bb4-9fd7-0a3de262679e': 1, '9046e87c-846d-4879-9189-f8ce1b0fcfea': 1, '16094795-1c09-47ce-875d-30601ccbe5e6': 1, '93898ec1-6c90-4d1e-ba12-b607e840381f': 1, '85d54764-dcaa-45e5-9ab4-a5ddc84ac71d': 1, '0dfb7f20-215d-4c6a-adab-8438e5cd30a4': 1, 'b4dfbb76-e130-495f-adc6-2db91ef9b537': 1, '64912558-ce3e-42fc-aeda-af7a091ad19b': 1, 'cc73f305-3c44-4ec6-92cb-eba280f8c11c': 1})",
      "",
      "# Start of circuit: final circuit",
      "# Start of circuit: measure rsc_block_0 syndromes 3 time(s)",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 0",
      "qml.measure(6, reset=True)",
      "qml.measure(15, reset=True)",
      "qml.measure(8, reset=True)",
      "qml.measure(13, reset=True)",
      "qml.measure(2, reset=True)",
      "qml.measure(16, reset=True)",
      "qml.measure(11, reset=True)",
      "qml.measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_0\"] = qml.measure(6)",
      "measurements[\"c_(2, 2, 1)_0\"] = qml.measure(15)",
      "measurements[\"c_(1, 2, 1)_0\"] = qml.measure(8)",
      "measurements[\"c_(2, 1, 1)_0\"] = qml.measure(13)",
      "measurements[\"c_(0, 1, 1)_0\"] = qml.measure(2)",
      "measurements[\"c_(3, 2, 1)_0\"] = qml.measure(16)",
      "measurements[\"c_(2, 0, 1)_0\"] = qml.measure(11)",
      "measurements[\"c_(1, 3, 1)_0\"] = qml.measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 0",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 1",
      "qml.measure(6, reset=True)",
      "qml.measure(15, reset=True)",
      "qml.measure(8, reset=True)",
      "qml.measure(13, reset=True)",
      "qml.measure(2, reset=True)",
      "qml.measure(16, reset=True)",
      "qml.measure(11, reset=True)",
      "qml.measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_1\"] = qml.measure(6)",
      "measurements[\"c_(2, 2, 1)_1\"] = qml.measure(15)",
      "measurements[\"c_(1, 2, 1)_1\"] = qml.measure(8)",
      "measurements[\"c_(2, 1, 1)_1\"] = qml.measure(13)",
      "measurements[\"c_(0, 1, 1)_1\"] = qml.measure(2)",
      "measurements[\"c_(3, 2, 1)_1\"] = qml.measure(16)",
      "measurements[\"c_(2, 0, 1)_1\"] = qml.measure(11)",
      "measurements[\"c_(1, 3, 1)_1\"] = qml.measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 1",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 2",
      "qml.measure(6, reset=True)",
      "qml.measure(15, reset=True)",
      "qml.measure(8, reset=True)",
      "qml.measure(13, reset=True)",
      "qml.measure(2, reset=True)",
      "qml.measure(16, reset=True)",
      "qml.measure(11, reset=True)",
      "qml.measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_2\"] = qml.measure(6)",
      "measurements[\"c_(2, 2, 1)_2\"] = qml.measure(15)",
      "measurements[\"c_(1, 2, 1)_2\"] = qml.measure(8)",
      "measurements[\"c_(2, 1, 1)_2\"] = qml.measure(13)",
      "measurements[\"c_(0, 1, 1)_2\"] = qml.measure(2)",
      "measurements[\"c_(3, 2, 1)_2\"] = qml.measure(16)",
      "measurements[\"c_(2, 0, 1)_2\"] = qml.measure(11)",
      "measurements[\"c_(1, 3, 1)_2\"] = qml.measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 2",
      "#  End of circuit: measure rsc_block_0 syndromes 3 time(s)",
      "# Start of circuit: measure logical z of rsc_block_0",
      "measurements[\"c_(0, 0, 0)_0\"] = qml.measure(0)",
      "measurements[\"c_(0, 1, 0)_0\"] = qml.measure(1)",
      "measurements[\"c_(0, 2, 0)_0\"] = qml.measure(3)",
      "measurements[\"c_(1, 0, 0)_0\"] = qml.measure(4)",
      "measurements[\"c_(1, 1, 0)_0\"] = qml.measure(5)",
      "measurements[\"c_(1, 2, 0)_0\"] = qml.measure(7)",
      "measurements[\"c_(2, 0, 0)_0\"] = qml.measure(10)",
      "measurements[\"c_(2, 1, 0)_0\"] = qml.measure(12)",
      "measurements[\"c_(2, 2, 0)_0\"] = qml.measure(14)",
      "#  End of circuit: measure logical z of rsc_block_0",
      "#  End of circuit: final circuit"
    ],
    "program_catalyst": [
      "# PennyLane Program Generated from Eka",
      "# Initialize Wires from Eka quantum channels Ids",
      "measurements = {}",
      "qml.registers({'18fd1e99-8138-46b9-850a-3004023e734c': 1, 'c3802286-62d9-4702-867c-f421a5706fdb': 1, '9109776f-b2b5-4a85-af3f-f9862283e382': 1, '0d96476e-f629-4701-a080-e9911772fd0a': 1, '1c2374ec-a571-45d1-b2c9-9b62c472bba4': 1, 'e2844eb8-c1f1-48e0-ae21-40b43679b1a1': 1, '9401da9b-0e25-42ab-a4c0-9edd525c0f5c': 1, '661c4117-a206-40e2-8443-3ebde436baa1': 1, 'fc208dd7-5dd5-4f5a-9540-20e0db1991cf': 1, 'a6fe6d44-61ae-4745-b117-5100bbc70c2c': 1, '3fdc17e4-ebb9-4b62-96c7-984f69f7e0ea': 1, 'd37ee11e-2dc2-4f21-a2b2-8c37af6f8dd0': 1, '71a76219-4d8c-41c3-9c72-6af354dbc42f': 1, '31ba59c3-b1b8-41c4-9dd2-5f59b577745a': 1, '48590c52-7fba-4d2b-9a40-e64e0cedd395': 1, '5c94ec78-dd71-4678-ba62-9446014f6663': 1, '7ca5944e-2a36-4224-8e90-1d7e436804c2': 1})",
      "",
      "# Start of circuit: final circuit",
      "# Start of circuit: measure rsc_block_0 syndromes 3 time(s)",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 0",
      "catalyst_measure(6, reset=True)",
      "catalyst_measure(15, reset=True)",
      "catalyst_measure(8, reset=True)",
      "catalyst_measure(13, reset=True)",
      "catalyst_measure(2, reset=True)",
      "catalyst_measure(16, reset=True)",
      "catalyst_measure(11, reset=True)",
      "catalyst_measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_0\"] = catalyst_measure(6)",
      "measurements[\"c_(2, 2, 1)_0\"] = catalyst_measure(15)",
      "measurements[\"c_(1, 2, 1)_0\"] = catalyst_measure(8)",
      "measurements[\"c_(2, 1, 1)_0\"] = catalyst_measure(13)",
      "measurements[\"c_(0, 1, 1)_0\"] = catalyst_measure(2)",
      "measurements[\"c_(3, 2, 1)_0\"] = catalyst_measure(16)",
      "measurements[\"c_(2, 0, 1)_0\"] = catalyst_measure(11)",
      "measurements[\"c_(1, 3, 1)_0\"] = catalyst_measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 0",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 1",
      "catalyst_measure(6, reset=True)",
      "catalyst_measure(15, reset=True)",
      "catalyst_measure(8, reset=True)",
      "catalyst_measure(13, reset=True)",
      "catalyst_measure(2, reset=True)",
      "catalyst_measure(16, reset=True)",
      "catalyst_measure(11, reset=True)",
      "catalyst_measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_1\"] = catalyst_measure(6)",
      "measurements[\"c_(2, 2, 1)_1\"] = catalyst_measure(15)",
      "measurements[\"c_(1, 2, 1)_1\"] = catalyst_measure(8)",
      "measurements[\"c_(2, 1, 1)_1\"] = catalyst_measure(13)",
      "measurements[\"c_(0, 1, 1)_1\"] = catalyst_measure(2)",
      "measurements[\"c_(3, 2, 1)_1\"] = catalyst_measure(16)",
      "measurements[\"c_(2, 0, 1)_1\"] = catalyst_measure(11)",
      "measurements[\"c_(1, 3, 1)_1\"] = catalyst_measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 1",
      "# Start of circuit: measure rsc_block_0 syndromes - cycle 2",
      "catalyst_measure(6, reset=True)",
      "catalyst_measure(15, reset=True)",
      "catalyst_measure(8, reset=True)",
      "catalyst_measure(13, reset=True)",
      "catalyst_measure(2, reset=True)",
      "catalyst_measure(16, reset=True)",
      "catalyst_measure(11, reset=True)",
      "catalyst_measure(9, reset=True)",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "qml.CZ([6, 4])",
      "qml.CZ([15, 12])",
      "qml.CNOT([8, 5])",
      "qml.CNOT([13, 10])",
      "qml.CNOT([2, 0])",
      "qml.CZ([9, 7])",
      "qml.CZ([6, 0])",
      "qml.CZ([15, 5])",
      "qml.CNOT([8, 7])",
      "qml.CNOT([13, 12])",
      "qml.CNOT([2, 1])",
      "qml.CZ([9, 3])",
      "qml.CZ([6, 5])",
      "qml.CZ([15, 14])",
      "qml.CNOT([8, 1])",
      "qml.CNOT([13, 4])",
      "qml.CNOT([16, 12])",
      "qml.CZ([11, 10])",
      "qml.CZ([6, 1])",
      "qml.CZ([15, 7])",
      "qml.CNOT([8, 3])",
      "qml.CNOT([13, 5])",
      "qml.CNOT([16, 14])",
      "qml.CZ([11, 4])",
      "qml.Hadamard([6])",
      "qml.Hadamard([15])",
      "qml.Hadamard([8])",
      "qml.Hadamard([13])",
      "qml.Hadamard([2])",
      "qml.Hadamard([16])",
      "qml.Hadamard([11])",
      "qml.Hadamard([9])",
      "measurements[\"c_(1, 1, 1)_2\"] = catalyst_measure(6)",
      "measurements[\"c_(2, 2, 1)_2\"] = catalyst_measure(15)",
      "measurements[\"c_(1, 2, 1)_2\"] = catalyst_measure(8)",
      "measurements[\"c_(2, 1, 1)_2\"] = catalyst_measure(13)",
      "measurements[\"c_(0, 1, 1)_2\"] = catalyst_measure(2)",
      "measurements[\"c_(3, 2, 1)_2\"] = catalyst_measure(16)",
      "measurements[\"c_(2, 0, 1)_2\"] = catalyst_measure(11)",
      "measurements[\"c_(1, 3, 1)_2\"] = catalyst_measure(9)",
      "#  End of circuit: measure rsc_block_0 syndromes - cycle 2",
      "#  End of circuit: measure rsc_block_0 syndromes 3 time(s)",
      "# Start of circuit: measure logical z of rsc_block_0",
      "measurements[\"c_(0, 0, 0)_0\"] = catalyst_measure(0)",
      "measurements[\"c_(0, 1, 0)_0\"] = catalyst_measure(1)",
      "measurements[\"c_(0, 2, 0)_0\"] = catalyst_measure(3)",
      "measurements[\"c_(1, 0, 0)_0\"] = catalyst_measure(4)",
      "measurements[\"c_(1, 1, 0)_0\"] = catalyst_measure(5)",
      "measurements[\"c_(1, 2, 0)_0\"] = catalyst_measure(7)",
      "measurements[\"c_(2, 0, 0)_0\"] = catalyst_measure(10)",
      "measurements[\"c_(2, 1, 0)_0\"] = catalyst_measure(12)",
      "measurements[\"c_(2, 2, 0)_0\"] = catalyst_measure(14)",
      "#  End of circuit: measure logical z of rsc_block_0",
      "#  End of circuit: final circuit"
    ]
  }
}